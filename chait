// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Test} from "forge-std/Test.sol";
import {console} from "forge-std/console.sol";
import {AccessControlRegistry} from "../src/access/AccessControlRegistry.sol";
import {AccountingIndexes} from "../src/calculations-contracts/AccountingIndexes.sol";
import {Roles} from "../src/utils/Roles.sol";
import {DebentureEnums} from "../src/lib/DebentureEnums.sol";
import {DIOverMath} from "../src/lib/DIOverMath.sol";

contract AccountingIndexesTest is Test {
    AccountingIndexes internal accounting;
    AccessControlRegistry internal accessControlRegistry;

    // Roles
    bytes32 internal constant OPERATOR_ROLE = Roles.OPERATOR;
    bytes32 internal constant ADMIN_ROLE = Roles.ADMIN;

    // Users
    address internal operator;
    address internal otherAccount;
    address internal adminUser;

    event IndexFactorCalculated(
        uint256 requestId,
        uint256 timestamp,
        uint256 nik,
        uint256 nik_1,
        uint256 daysNum,
        uint256 daysDen,
        uint256 newCwad,
        uint256 vna
    );

    function setUp() public {
        operator = makeAddr("operator");
        otherAccount = makeAddr("otherAccount");
        adminUser = makeAddr("adminUser");

        accessControlRegistry = new AccessControlRegistry();
        accessControlRegistry.initialize();

        accounting = new AccountingIndexes(
            address(accessControlRegistry)
        );

        accessControlRegistry.grantRole(OPERATOR_ROLE, operator);
        accessControlRegistry.grantRole(ADMIN_ROLE, adminUser);
        accessControlRegistry.grantRole(OPERATOR_ROLE, address(accounting));

        // garante que block.timestamp é bem maior que 30 dias
        vm.warp(100 days); // 8640000
    }

    function test_Revert_When_Caller_Is_Not_Operator() public {
        vm.prank(otherAccount);
        vm.expectRevert();

        accounting.calculateIndexFactor(
            1,
            1e18,
            58000,
            57500,
            block.timestamp,
            block.timestamp - 30 days,
            1e18,
            DebentureEnums.DayBasisRemuneration.DiasCorridos365
        );
    }

    function test_calculateIndexFactor() public {
        uint256 requestId = 10;

        uint256 previousCwad = 1e18; // C acumulado anterior
        uint256 vne = 1e18;

        uint256 nik   = 58320; // número-índice atual
        uint256 nik_1 = 58000; // número-índice anterior

        // birthday há 15 dias
        uint256 birthday = block.timestamp - 15 days;

        uint256 expected_daysNum = 15;
        uint256 expected_daysDen = 30;

        // Valor que vimos no trace retornado pelo contrato:
        // 1002759124650065459
        uint256 expectedC = 1002759124650065459;
        uint256 expectedVna = expectedC; // vne = 1e18

        vm.startPrank(operator);

        vm.expectEmit(true, true, true, true);
        emit IndexFactorCalculated(
            requestId,
            block.timestamp,
            nik,
            nik_1,
            expected_daysNum,
            expected_daysDen,
            expectedC,
            expectedVna
        );

        (uint256 newCwad, uint256 vna) = accounting.calculateIndexFactor(
            requestId,
            previousCwad,
            nik,
            nik_1,
            block.timestamp,
            birthday,
            vne,
            DebentureEnums.DayBasisRemuneration.DiasCorridos365
        );

        vm.stopPrank();

        // Pequena tolerância por conta de ln/exp (se quiser pode usar assertEq direto)
        assertApproxEqAbs(newCwad, expectedC, 1e10, "Cwad mismatch");
        assertApproxEqAbs(vna, expectedVna, 1e10, "VNA mismatch");

        console.log("newCwad:", newCwad);
        console.log("vna:", vna);
    }

    function test_calculateFullPeriod() public {
        uint256 requestId = 2;
        uint256 previousCwad = 1e18;
        uint256 vne = 1000e18;

        uint256 nik   = 60000;
        uint256 nik_1 = 58000;

        // aniversário há 30 dias exatos
        uint256 birthday = block.timestamp - 30 days;

        vm.startPrank(operator);

        (uint256 newCwad, uint256 vna) = accounting.calculateIndexFactor(
            requestId,
            previousCwad,
            nik,
            nik_1,
            block.timestamp,
            birthday,
            vne,
            DebentureEnums.DayBasisRemuneration.DiasCorridos365
        );

        vm.stopPrank();

        // valida comportamento: fator > 1 e VNA > VNE
        assertGt(newCwad, previousCwad, "Factor should increase");
        assertGt(vna, vne, "VNA should increase");
    }

    function test_calculateIndexBusinessDays() public {
        uint256 requestId = 5;
        uint256 previousCwad = 1e18;
        uint256 vne = 1e18;

        uint256 nik   = 58320;
        uint256 nik_1 = 58000;

        // birthday há 10 dias
        uint256 birthday = block.timestamp - 10 days;

        vm.startPrank(operator);
        (uint256 newCwad, uint256 vna) = accounting.calculateIndexFactor(
            requestId,
            previousCwad,
            nik,
            nik_1,
            block.timestamp,
            birthday,
            vne,
            DebentureEnums.DayBasisRemuneration.DiasUteis252
        );
        vm.stopPrank();

        assertGt(newCwad, previousCwad);
        assertGt(vna, vne);
    }
}
