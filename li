// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

/// @title DIOverMath - Math utilities for WAD-based financial calculations
/// @notice Provides fixed-point arithmetic and financial functions such as exponentiation, logarithms, and rounding.
library DIOverMath {
    
    // ========= Constants =========
    int256 internal constant WAD = 1e18;
    int256 internal constant HALF_WAD = 5e17;
    uint256 internal constant WAD_TO_2 = 1e16;
    int256 internal constant EPS = 1;
    uint256 internal constant MAX_ITER = 60;
    uint256 internal constant WAD_TO_8 = 1e10;
    uint256 internal constant WAD_TO_9 = 1e9;
    uint256 internal constant WAD_TO_16 = 1e2;
    uint256 internal constant SCALE_8 = 1e8;

    /**
     * @notice Multiplies two WAD values with rounding.
     * @param x First operand in WAD.
     * @param y Second operand in WAD.
     * @return Result of (x * y) / WAD with rounding.
     */
    function mulWad(int256 x, int256 y) internal pure returns (int256) {
        int256 prod = x * y;
        int256 half = prod >= 0 ? HALF_WAD : -HALF_WAD;
        return (prod + half) / WAD;
    }

    /**
     * @notice Divides two integers and returns result in WAD format.
     * @param x Numerator.
     * @param y Denominator.
     * @return Result of (x / y) in WAD.
     */
    function divWad(int256 x, int256 y) internal pure returns (int256) {
        require(y != 0, "DIV_BY_ZERO");
        int256 num = x * WAD;
        int256 half = ((x ^ y) >= 0) ? HALF_WAD : -HALF_WAD;
        return (num + half) / y;
    }

    /**
     * @notice Performs integer division with rounding.
     * @param x Numerator.
     * @param d Denominator.
     * @return Rounded result of x / d.
     */
    function divIntRound(int256 x, int256 d) internal pure returns (int256) {
        require(d != 0, "DIV0");
        int256 q = x / d;
        int256 r = x % d;
        if (r == 0) return q;
        int256 absR = r >= 0 ? r : -r;
        int256 absD = d >= 0 ? d : -d;
        bool sameSign = (x ^ d) >= 0;
        if (absR * 2 >= absD) {
            q += sameSign ? int256(1) : int256(-1);
        }
        return q;
    }

    /**
     * @notice Computes the natural logarithm of a WAD value.
     * @param xWad Input value in WAD.
     * @return Natural logarithm of xWad in WAD.
     */
    function lnWad(uint256 xWad) internal pure returns (int256) {
        require(xWad > 0, "LN_DOMAIN");
        int256 x = int256(xWad);

        int256 t = divWad(x - WAD, x + WAD);
        int256 t2 = mulWad(t, t);
        int256 term = t;
        int256 sum = 0;
        uint256 k = 1;

        for (uint256 i = 0; i < MAX_ITER; i++) {
            int256 add = divIntRound(term, int256(k));
            sum += add;
            int256 absAdd = add >= 0 ? add : -add;
            if (absAdd <= EPS) break;
            term = mulWad(term, t2);
            k += 2;
        }
        return sum * 2;
    }

    /**
     * @notice Computes the exponential of a WAD value.
     * @param z Input value in WAD.
     * @return Exponential of z in WAD.
     */
    function expWad(int256 z) internal pure returns (int256) {
        require(z > -90e18 && z < 90e18, "EXP_RANGE");
        int256 term = WAD;
        int256 sum  = WAD;
        for (uint256 n = 1; n <= MAX_ITER; n++) {
            term = mulWad(term, z);
            term = divIntRound(term, int256(n));
            sum += term;
            int256 absTerm = term >= 0 ? term : -term;
            if (absTerm <= EPS) break;
        }
        return sum;
    }

    /**
     * @notice Computes fractional exponentiation of a WAD value.
     * @param xWad Base value in WAD.
     * @param num Numerator of the exponent.
     * @param den Denominator of the exponent.
     * @return Result of xWad^(num/den) in WAD.
     */
    function powFractionWad(uint256 xWad, uint256 num, uint256 den) internal pure returns (uint256) {
        require(xWad > 0, "POW_DOMAIN");
        require(den != 0, "POW_DEN0");
        int256 yWad = int256((uint256(uint128(uint256(WAD))) * num) / den);
        int256 lnX = lnWad(xWad);
        int256 z = mulWad(yWad, lnX);
        int256 e = expWad(z);
        require(e > 0, "EXP_NEG");
        return uint256(e);
    }

    /**
     * @notice Rounds a WAD rate to 8 decimal places using either classic or custom rounding.
     * @param rateWad Rate in WAD format.
     * @param HALF_UP If true, rounds up if 9th digit >= 5; if false, rounds up only if >= 6.
     * @return Rounded rate in WAD with 8 effective decimals.
     */
    function roundTDIk8_fromWad(uint256 rateWad, bool HALF_UP) internal pure returns (uint256) {
        uint256 base8 = rateWad / WAD_TO_8;
        uint256 ninth = (rateWad / WAD_TO_9) % 10;

        if (HALF_UP) {
            if (ninth >= 5) base8 += 1;
        } else {
            if (ninth >= 6) base8 += 1;
        }
        return base8 * WAD_TO_8;
    }

    /**
     * @notice Computes TDIk = (1 + CDI_aa)^(1/252) - 1, rounded to 8 decimals.
     * @param cdiAaWad Annual CDI rate in WAD format.
     * @param HALF_UP Rounding mode for TDIk.
     * @return TDIk rate in WAD with 8 effective decimals.
     */
    function dailyRateTDIkRounded8FromAnnual(uint256 cdiAaWad, bool HALF_UP) internal pure returns (uint256) {
        uint256 base = uint256(int256(WAD) + int256(cdiAaWad));
        uint256 factor = powFractionWad(base, 1, 252);
        uint256 rateRaw = factor - uint256(int256(WAD));
        return roundTDIk8_fromWad(rateRaw, HALF_UP);
    }

    /**
     * @notice Calculates the updated PU (unit price).
     * @param _vne Nominal value of the debenture.
     * @param _accumulatedInterestFactor Accumulated interest factor in WAD.
     * @return Updated PU in WAD.
     */
    function calculateInterestUnit(
        uint256 _vne,
        uint256 _accumulatedInterestFactor
    ) internal pure returns (uint256) {
        uint256 pu = _accumulatedInterestFactor + _vne;
        require(pu >= 0, "Negative PU");

        return uint256(pu);
    }
}
